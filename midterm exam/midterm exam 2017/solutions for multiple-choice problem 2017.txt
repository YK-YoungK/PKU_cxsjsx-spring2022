http://cxsjsx.openjudge.cn/midtermchoicechn2017/

各题做对人数：

****1 360
2 389
3 416
4 376
5 374
6 408
7 363
****8 336
9 403
10 374
11 395
12 424
13 413
14 382
****15 326
****16 356
17 385
18 399
19 389
****20 265



1) 关于复制构造函数，下列说法正确的是
A. 系统不会生成缺省复制构造函数，因此必须自己实现
B. 复制构造函数是形如X::X(X)的函数
C.  Myclass c1, c2;	 c1.n = 1;	 c2 = c1;第三句将会调用复制构造函数
D. 调用函数A Func() {   A a(4);    return a;   }时，将会调用A的复制构造函数
#D 
**复制构造函数

2)关于虚函数，下列说法不正确的是
A. 不允许以虚函数作为构造函数
B. 没有虚函数便无法实现多态
C. 一般来讲，如果一个类中定义了虚函数，则不可将析构函数也定义为虚函数
D. 不能用抽象类定义对象
#C
**虚函数和抽象类

3)下列类模板不支持迭代器的是
A.stack
B.vector
C.list
D.set
#A
**STL迭代器

4) 关于 this 指针，以下说法不正确的是
A. static成员函数内部不可以使用this指针 
B. 在构造函数内部可以使用this指针 
C. 在析构函数内部可以使用 this 指针
D. const成员函数内部不可以使用this 指针  
#D
**this指针

5) 将一个对象放入STL中的容器里时，以下说法正确的是 
A. 实际上被放入的是该对象的指针 
B. 实际上被放入的是该对象的一个拷贝（副本） 
C. 实际上被放入的是该对象的引用 
D. 实际上被放入的就是该对象自身
#B
**STL容器和对象的关系

6） 关于顺序容器迭代器的操作，不正确的是
A. vector<int>::iterator iter1, iter2; iter1<iter2;
B．list<int>::iterator iter1, iter2; iter1<iter2;
C. vector<int>::iterator iter1, iter2; iter1-=3;
D. deque<int>::iterator iter1; iter1+=5;
#B
**STL迭代器

7)  map的每个元素包括KEY(first）和VALUE(second)。关于map容器，下列哪种说法错误
A.  map支持下标运算符
B.  map的不同元素可以有相同的VALUE 
C.  map支持STL的sort算法
D.  map支持双向迭代器
#C
**map

8) 下列哪个运算符可以被重载
A.  ->
B.  ?:
C.  .
D.  ::
#A
**运算符重载

9)  关于类的static成员函数，下列哪个说法正确
A.  static成员函数中，可以访问当前类的virtual成员函数
B.  static成员函数中，可以访问父类的private成员函数
C.  static成员函数中，不允许调用当前类的非const成员函数
D.  static成员函数中，不允许使用this指针 
#D
**静态成员函数、虚函数、this指针

10)  下列说法错误的是
A.  可以在一个类的友元函数中使用this指针
B  每个类只有一个析构函数
C  抽象类至少包含一个纯虚函数
D  构造函数不可以是virtual函数
#A
**综合

11) 下列说法正确的是
A.  每个类至少有两个构造函数
B.  构造函数的返回值必须是void类型的
C.  有可能通过基类的指针调用派生类的virtual函数
D.  C++语法不允许派生类的成员变量和基类的成员变量同名
#C
**综合

12) 下列关于运算符重载的描述中，正确的是: 
A. 运算符只能被重载一次
B. 流插入运算符 “<<” 可以是类的友元函数
C. 所有的运算符可以被重载为普通函数，也可以重载为成员函数
D. 运算符重载可以改变运算符的优先级
#B
**运算符重载

13) 关于继承和派生的描述中，下列说法错误的是:
A. 派生类的成员函数中，不能访问基类的private成员
B. 在派生类的析构函数执行之前，会先调用基类的析构函数
C. 派生类对象的地址可以赋值给基类指针
D. 派生类可以有和基类同名同参数的成员函数`
#B
**继承和派生

14) 以下哪种使用std::sort算法的方式是不合法的： 
A. vector<int> a; …; sort(a.begin(), a.end());
B. bool b[99]; …; sort(b, b + 99);
C. string c = “2333”; …; sort(c.begin(), c.end());
D. list<int> d; …; sort(d.begin(), d.end());
#D
**STL sort算法

15) 类A重载的运算符声明是int operator<(A &other) const，那么以下说法中正确的是：
A. 小于号左侧的A对象不可以是const的
B. 小于号右侧的A对象不可以是const的
C. 这个写法是错误的，因为小于号的返回类型必须是bool
D. 使用小于号的时候，other参数处，传进来的对象实际上会被复制一次
#B
**综合

16) 系统在调用重载函数时，往往根据一些条件确定哪个重载函数被调用，在下列选项中，不能作为依据的是_____。 
A. 参数个数 
B. 参数的类型
C. 函数的返回值的类型
D. 以上都可以
#C
**重载函数

17) 关于构造函数，下列选项错误的是____:
A. 构造函数可以是虚函数 
B. 构造函数的参数可以有缺省值
C. 定义了构造函数，则编译器不生成默认的无参数的构造函数
D. 构造函数不能继承
#A
**构造函数和继承

18) 以下顺序容器不支持随机访问迭代器的是：
A. vector
B. deque
C. list
D. 以上容器都支持
#C
**容器和迭代器

19) 以下STL中的函数模板哪个可以作用于set
A. sort
B. random_shuffle
C. find
D. 都不行
#C
**算法和容器

20) 以下关于多态的说法那个不正确?
A.  在成员函数中调用虚函数，是多态
B.  通过“基类对象名.函数名"的方式调用虚函数，不是多态
C.  多态的函数调用语句中，函数一定是虚函数
D.  通过“基类引用名.函数名"的方式调用虚函数，是多态
#A
**多态 构造函数中调用虚函数不是多态