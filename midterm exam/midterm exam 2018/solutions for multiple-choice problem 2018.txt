考试地址：http://cxsjsx.openjudge.cn/2018midexamchoice/

推荐题目：
1,4,7,13,14,16,20


1) 以下说法正确的是:
A. 一旦某个类的成员函数被声明为虚函数，则在该类的所有派生类中和它同名同参数表的成员函数都是虚函数
B. 只要基类有无参构造函数，则派生类的构造函数就可以不带初始化列表
C. 存在从基类对象向派生类对象的隐式类型转换（自动类型转换）
D. 对虚函数的调用，在编译时就可确定调用哪个类的虚函数
#A
**虚函数  B错是因为派生类可能是封闭类

2) 在以下哪种情形，复制构造函数会被调用。
A. 当一个对象采用引用方式，作为参数传递给一个函数
B. 当一个函数返回一个对象
C. 当一个对象赋值给另一个对象
D. 以上答案都不对
#B
**复制构造函数

3)下列关于引用的说法，错误的是
A. 声明引用时，必须同时对其进行初始化
B. 引用一旦初始化后就不能再令其引用其它变量
C. 不可以用常量来初始化非常量引用
D. 常引用所引用的变量是不可修改的
#D
**引用

4)以下STL中的函数模板哪个可以作用于vector
A. lower_bound
B. random_shuffle
C. unique
D. 都可以
#D
**STL算法适用的容器

5)下列STL模板中，不支持随机访问迭代器的是
A. queue
B. vector
C. deque
D. string
#A
**容器的迭代器类型

6)关于模板，以下说法正确的是？
A. 模板形参只能是类型形参
B. 类模板可以重载
C. 函数模板可以重载
D. 使用同一个类模板实例化出来的不同类的对象可以直接互相赋值
#C
**模板基本概念

7)关于容器，以下说法不正确的是？
A. map容器可以显式定义Key的排序方式
B. 顺序容器中，在中间插入元素时，list容器的插入成本最低
C. 顺序容器都可以使用STL algorithm里的sort函数
D. vector容器中的元素要求存放在连续的内存中
#C
**STL 容器      
sort不能用于list，这很明显。严格说vector容器怎么实现取决于编译器

8)关于容器迭代器，以下说法正确的是？
A. 关联容器迭代器不支持++操作
B. 顺序容器迭代器都支持 < 操作
C. 容器适配器不支持迭代器操作
D. 对于list容器的insert操作，insert(iter, element)会在iter指向的位置后面插入元素element
#C
**容器的迭代器类型

9)关于运算符重载，下列说法错误的是
A. C++允许用户自定义新的运算符进行重载
B. 当*作为单目运算符时，可以进行重载
C. 重载运算符函数不能有默认参数
D. 重载()运算符时，参数个数可以为任意多个
#A
**运算符重载

10) 下列说法中正确的是
A. 可以用参数初始化表对静态数据成员初始化
B. 静态数据成员初始化语句的一般形式为 static 类名：：静态数据成员名=初值
C. 在类外可以通过对象名引用public静态数据成员，也可以通过类名引用
D. 静态数据成员不能在类体外进行初始化
#C
**静态成员

11) 如果一个函数是类A的友元函数，下列哪一项是错误的？
A. 该函数只能由类A本身声明为友元
B. 该友元函数不是类A的成员
C. 该友元函数是类A的成员
D. 该友元函数可以访问类A的私有的成员 
#C
**友元

12) 在C ++中，const限定符可以应用于

1 类的成员函数 2 函数参数 3 静态成员变量 4 引用

A. 1,2,3。
B. 1,2,4
C.  所有
D. 1,3,4
#C
**引用

13) 关于构造函数，以下说法正确的是：
A)只有一个参数的构造函数是类型转换构造函数。
B)构造函数不可以被重载。
C)构造函数可以是私有的。
D)构造函数可以是虚函数。
#C
**构造函数

14) 以下说法不正确的是：

A. 在公有派生的情况下，派生类对象的地址可以直接赋值给基类指针。
B. 在公有派生的情况下，派生类对象可以直接赋值给基类对象。
C. 类的成员函数可以访问其他同类对象的private成员。
D. 类的成员函数可以访问其他基类对象的protected成员。
#D
**继承

15)
template < class T, int size >

class CArray {

static int count;

...    

};

其中没有用户自定义的构造函数。

由该类模版实例化的两个模版类 ，并且有两个对象：

CArray < int, 40 >  c40;

CArray < int, 50> c50;


以下各个说法正确的个数是：

i.CArray < int, 40 >的对象直接可以用CArray < int, 50 >的对象赋值

ii.c40修改静态变量count会改变c50中的静态变量count

iii.指针CArray < int, 40> * p可以直接指向CArray < int, 50 > 的对象


A)0

B)1

C)2

D)3

#A
**模板

16) 以下说法正确的个数是：

i. ostream类有公有的无参构造函数，可以用于定义ostream类的对象

ii. ostream类有公有的复制构造函数，可以用于复制ostream类的对象

iii. while(cin>>n>>m) 这个语句可以一直输入直到结束，是因为用户重载了流输入运算符>>并且让它在输入出错的时候返回0，正确的时候返回1


A)0

B)1

C)2

D)3

#A
**运算符重载   重载 >> 只能返回 ostream的引用，不能返回0或者1

17) 以下关于静态成员的说法错误的是

A. 静态成员变量不属于某个特定对象

B. 对静态成员也可以指定为private或public

C. 若某类没有对象存在，该类的静态成员变量就不存在

D. 在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数
#C
**静态成员

18) 以下容器中，元素的插入位置与元素的值有关的是

A. vector

B. list

C. map

D. deque

#C
**STL容器性质

19)在构造某一个封闭派生类的对象时，关于基类、成员对象类和派生类的构造函数执行顺序，以下说法正确的是

A.依次是基类、成员对象类、派生类

B.依次是成员对象类、基类、派生类

C.依次是派生类、基类、成员对象类

D.跟初始化列表的顺序有关
#A
**封闭类对象初始化

20) 下列关于运算符重载说法中错误的是：

A. 重载运算符() 和[ ] 时，运算符重载函数必须声明为类的成员函数

B. “::”、“.”、“sizeof”均不能被重载

C. C++不允许用户自己定义新的运算符,只能对已经存在的操作符进行重载

D. “=” 可以重载为成员函数，也可以重载为非成员函数
#D
**运算符重载



